#!/usr/bin/env python3
"""
Ëá™Âä®‰∫§ÊòìÁ≥ªÁªüÊºîÁ§∫ËÑöÊú¨
‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆÂ±ïÁ§∫Á≥ªÁªüÂäüËÉΩ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import os
import sys

# Ê∑ªÂä†È°πÁõÆË∑ØÂæÑ
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from modules.strategy_module import TrendFollowingStrategy
from modules.risk_control_module import RiskControlModule
from modules.execution_module import ExecutionModule
from modules.utils import DataProcessor

def generate_mock_data(symbol="BTC/USDT", days=365, start_price=50000):
    """ÁîüÊàêÊ®°ÊãüÁöÑ‰ª∑Ê†ºÊï∞ÊçÆ"""
    print(f"üìä ÁîüÊàê{symbol}Ê®°ÊãüÊï∞ÊçÆ...")
    
    # ÁîüÊàêÊó∂Èó¥Â∫èÂàó
    start_date = datetime.now() - timedelta(days=days)
    dates = pd.date_range(start=start_date, periods=days*24, freq='h')
    
    # ÁîüÊàê‰ª∑Ê†ºÊï∞ÊçÆÔºàÈöèÊú∫Ê∏∏Ëµ∞ + Ë∂ãÂäøÔºâ
    np.random.seed(42)  # Âõ∫ÂÆöÈöèÊú∫ÁßçÂ≠êÔºåÁ°Æ‰øùÁªìÊûúÂèØÈáçÁé∞
    
    # Âü∫Á°ÄÈöèÊú∫Ê∏∏Ëµ∞
    returns = np.random.normal(0, 0.02, len(dates))
    
    # Ê∑ªÂä†Ë∂ãÂäøÊàêÂàÜ
    trend = np.sin(np.arange(len(dates)) * 2 * np.pi / (30 * 24)) * 0.01
    returns += trend
    
    # ËÆ°ÁÆó‰ª∑Ê†º
    prices = [start_price]
    for ret in returns[1:]:
        prices.append(prices[-1] * (1 + ret))
    
    # ÁîüÊàêOHLCVÊï∞ÊçÆ
    data = []
    for i, (date, price) in enumerate(zip(dates, prices)):
        # Ê®°ÊãüÂºÄÈ´ò‰ΩéÊî∂
        open_price = price
        high_price = price * (1 + abs(np.random.normal(0, 0.005)))
        low_price = price * (1 - abs(np.random.normal(0, 0.005)))
        close_price = price * (1 + np.random.normal(0, 0.002))
        volume = np.random.uniform(100, 1000)
        
        data.append({
            'timestamp': date,
            'open': open_price,
            'high': high_price,
            'low': low_price,
            'close': close_price,
            'volume': volume
        })
    
    df = pd.DataFrame(data)
    df.set_index('timestamp', inplace=True)
    
    print(f"‚úÖ ÁîüÊàê‰∫Ü{len(df)}Êù°Êï∞ÊçÆÔºå‰ª∑Ê†ºËåÉÂõ¥: {df['close'].min():.2f} - {df['close'].max():.2f}")
    return df

def run_strategy_demo():
    """ËøêË°åÁ≠ñÁï•ÊºîÁ§∫"""
    print("\n" + "="*60)
    print("üöÄ Ëá™Âä®‰∫§ÊòìÁ≥ªÁªüÊºîÁ§∫")
    print("="*60)
    
    # 1. ÁîüÊàêÊ®°ÊãüÊï∞ÊçÆ
    btc_data = generate_mock_data("BTC/USDT", days=180, start_price=50000)
    eth_data = generate_mock_data("ETH/USDT", days=180, start_price=3000)
    
    # 2. ÂàùÂßãÂåñÁ≠ñÁï•
    print("\nüìà ÂàùÂßãÂåñË∂ãÂäøË∑üË∏™Á≠ñÁï•...")
    strategy_params = {
        'fast_ma': 20,
        'slow_ma': 50,
        'adx_period': 14,
        'adx_threshold': 25,
        'donchian_period': 20
    }
    
    btc_strategy = TrendFollowingStrategy(strategy_params)
    eth_strategy = TrendFollowingStrategy(strategy_params)
    
    # 3. ÂàùÂßãÂåñÈ£éÈô©ÊéßÂà∂
    print("üõ°Ô∏è ÂàùÂßãÂåñÈ£éÈô©ÊéßÂà∂Ê®°Âùó...")
    risk_config = {
        'max_position_size': 0.1,
        'max_total_position': 0.8,
        'max_drawdown': 0.2,
        'stop_loss': 0.02,
        'take_profit': 0.04,
        'initial_capital': 10000
    }
    risk_control = RiskControlModule(risk_config)
    
    # 4. ÂàùÂßãÂåñÊâßË°åÊ®°Âùó
    print("‚ö° ÂàùÂßãÂåñÊâßË°åÊ®°Âùó...")
    execution_config = {'commission': 0.001}
    execution = ExecutionModule(execution_config)
    
    # 5. ËøêË°åÂõûÊµã
    print("\nüîÑ ÂºÄÂßãÁ≠ñÁï•ÂõûÊµã...")
    
    # Â≠òÂÇ®‰∫§ÊòìËÆ∞ÂΩï
    trades = []
    portfolio_value = [risk_config['initial_capital']]
    dates = []
    
    # Ê®°Êãü‰∫§ÊòìËøáÁ®ã
    for i in range(100, len(btc_data)):  # ‰ªéÁ¨¨100‰∏™Êï∞ÊçÆÁÇπÂºÄÂßãÔºåÁ°Æ‰øùÊúâË∂≥Â§üÁöÑÂéÜÂè≤Êï∞ÊçÆ
        current_date = btc_data.index[i]
        dates.append(current_date)
        
        # Ëé∑ÂèñÂΩìÂâçÊï∞ÊçÆÂàáÁâá
        btc_slice = btc_data.iloc[:i+1]
        eth_slice = eth_data.iloc[:i+1]
        
        # ÁîüÊàê‰∫§Êòì‰ø°Âè∑
        btc_signals = btc_strategy.generate_signals(btc_slice)
        eth_signals = eth_strategy.generate_signals(eth_slice)
        
        current_value = portfolio_value[-1]
        
        # Â§ÑÁêÜBTC‰ø°Âè∑
        if len(btc_signals) > 0:
            latest_btc_signal = btc_signals.iloc[-1]
            if latest_btc_signal['signal'] != 0:
                # È£éÈô©Ê£ÄÊü•
                position_size = 0.05  # 5%‰ªì‰Ωç
                can_trade, reason, adjusted_size = risk_control.check_position_size(
                    "BTC/USDT", position_size, btc_slice['close'].iloc[-1]
                )
                
                if can_trade:
                    trade_amount = current_value * adjusted_size
                    price = btc_slice['close'].iloc[-1]
                    
                    if latest_btc_signal['signal'] > 0:  # ‰π∞ÂÖ•‰ø°Âè∑
                        trades.append({
                            'timestamp': current_date,
                            'symbol': 'BTC/USDT',
                            'side': 'buy',
                            'amount': trade_amount / price,
                            'price': price,
                            'value': trade_amount
                        })
                        current_value -= trade_amount * (1 + 0.001)  # Êâ£Èô§ÊâãÁª≠Ë¥π
                    
                    elif latest_btc_signal['signal'] < 0:  # ÂçñÂá∫‰ø°Âè∑
                        trades.append({
                            'timestamp': current_date,
                            'symbol': 'BTC/USDT',
                            'side': 'sell',
                            'amount': trade_amount / price,
                            'price': price,
                            'value': trade_amount
                        })
                        current_value += trade_amount * (1 - 0.001)  # Êâ£Èô§ÊâãÁª≠Ë¥π
        
        # Â§ÑÁêÜETH‰ø°Âè∑ÔºàÁ±ª‰ººÈÄªËæëÔºâ
        if len(eth_signals) > 0:
            latest_eth_signal = eth_signals.iloc[-1]
            if latest_eth_signal['signal'] != 0:
                position_size = 0.05
                can_trade, reason, adjusted_size = risk_control.check_position_size(
                    "ETH/USDT", position_size, eth_slice['close'].iloc[-1]
                )
                
                if can_trade:
                    trade_amount = current_value * adjusted_size
                    price = eth_slice['close'].iloc[-1]
                    
                    if latest_eth_signal['signal'] > 0:
                        trades.append({
                            'timestamp': current_date,
                            'symbol': 'ETH/USDT',
                            'side': 'buy',
                            'amount': trade_amount / price,
                            'price': price,
                            'value': trade_amount
                        })
                        current_value -= trade_amount * (1 + 0.001)
                    
                    elif latest_eth_signal['signal'] < 0:
                        trades.append({
                            'timestamp': current_date,
                            'symbol': 'ETH/USDT',
                            'side': 'sell',
                            'amount': trade_amount / price,
                            'price': price,
                            'value': trade_amount
                        })
                        current_value += trade_amount * (1 - 0.001)
        
        portfolio_value.append(current_value)
    
    # 6. ÂàÜÊûêÁªìÊûú
    print("\nüìä ÂõûÊµãÁªìÊûúÂàÜÊûê...")
    
    # ÂàõÂª∫ÁªìÊûúDataFrame
    results_df = pd.DataFrame({
        'timestamp': dates,
        'portfolio_value': portfolio_value[1:]  # ÂéªÊéâÂàùÂßãÂÄº
    })
    results_df.set_index('timestamp', inplace=True)
    
    # ËÆ°ÁÆóÊÄßËÉΩÊåáÊ†á
    returns = DataProcessor.calculate_returns(results_df['portfolio_value'])
    total_return = (results_df['portfolio_value'].iloc[-1] / risk_config['initial_capital'] - 1) * 100
    sharpe_ratio = DataProcessor.calculate_sharpe_ratio(returns)
    max_drawdown = DataProcessor.calculate_max_drawdown(results_df['portfolio_value']) * 100
    
    # ‰∫§ÊòìÁªüËÆ°
    trades_df = pd.DataFrame(trades)
    total_trades = len(trades_df)
    buy_trades = len(trades_df[trades_df['side'] == 'buy'])
    sell_trades = len(trades_df[trades_df['side'] == 'sell'])
    
    # ÊâìÂç∞ÁªìÊûú
    print(f"\n{'='*60}")
    print("üìà ÂõûÊµãÁªìÊûúÊëòË¶Å")
    print(f"{'='*60}")
    print(f"üìÖ ÂõûÊµãÊúüÈó¥: {results_df.index[0].strftime('%Y-%m-%d')} Ëá≥ {results_df.index[-1].strftime('%Y-%m-%d')}")
    print(f"üí∞ ÂàùÂßãËµÑÈáë: ${risk_config['initial_capital']:,.2f}")
    print(f"üí∞ ÊúÄÁªàËµÑÈáë: ${results_df['portfolio_value'].iloc[-1]:,.2f}")
    print(f"üìä ÊÄªÊî∂ÁõäÁéá: {total_return:.2f}%")
    print(f"üìä Â§èÊôÆÊØîÁéá: {sharpe_ratio:.4f}")
    print(f"üìä ÊúÄÂ§ßÂõûÊí§: {max_drawdown:.2f}%")
    print(f"üîÑ ÊÄª‰∫§ÊòìÊ¨°Êï∞: {total_trades}")
    print(f"üîÑ ‰π∞ÂÖ•Ê¨°Êï∞: {buy_trades}")
    print(f"üîÑ ÂçñÂá∫Ê¨°Êï∞: {sell_trades}")
    
    # 7. ÁîüÊàêÂõæË°®
    print("\nüìä ÁîüÊàêÂèØËßÜÂåñÂõæË°®...")
    
    plt.style.use('seaborn-v0_8')
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    fig.suptitle('Ëá™Âä®‰∫§ÊòìÁ≥ªÁªüÂõûÊµãÁªìÊûú', fontsize=16, fontweight='bold')
    
    # ËµÑÈáëÊõ≤Á∫ø
    axes[0, 0].plot(results_df.index, results_df['portfolio_value'], linewidth=2, color='blue')
    axes[0, 0].axhline(y=risk_config['initial_capital'], color='red', linestyle='--', alpha=0.7, label='ÂàùÂßãËµÑÈáë')
    axes[0, 0].set_title('ËµÑÈáëÊõ≤Á∫ø')
    axes[0, 0].set_ylabel('ËµÑÈáë ($)')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # Êî∂ÁõäÁéáÂàÜÂ∏É
    axes[0, 1].hist(returns, bins=30, alpha=0.7, color='green', edgecolor='black')
    axes[0, 1].set_title('Êî∂ÁõäÁéáÂàÜÂ∏É')
    axes[0, 1].set_xlabel('Êó•Êî∂ÁõäÁéá')
    axes[0, 1].set_ylabel('È¢ëÊ¨°')
    axes[0, 1].grid(True, alpha=0.3)
    
    # ‰ª∑Ê†ºËµ∞ÂäøÂØπÊØî
    axes[1, 0].plot(btc_data.index[-len(results_df):], btc_data['close'].iloc[-len(results_df):], 
                    label='BTC/USDT', alpha=0.8)
    axes[1, 0].plot(eth_data.index[-len(results_df):], eth_data['close'].iloc[-len(results_df):], 
                    label='ETH/USDT', alpha=0.8)
    axes[1, 0].set_title('‰ª∑Ê†ºËµ∞Âäø')
    axes[1, 0].set_ylabel('‰ª∑Ê†º ($)')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    
    # ‰∫§ÊòìÂàÜÂ∏É
    if total_trades > 0:
        symbol_counts = trades_df['symbol'].value_counts()
        axes[1, 1].pie(symbol_counts.values, labels=symbol_counts.index, autopct='%1.1f%%')
        axes[1, 1].set_title('‰∫§ÊòìÂàÜÂ∏É')
    else:
        axes[1, 1].text(0.5, 0.5, 'Êó†‰∫§ÊòìËÆ∞ÂΩï', ha='center', va='center', transform=axes[1, 1].transAxes)
        axes[1, 1].set_title('‰∫§ÊòìÂàÜÂ∏É')
    
    plt.tight_layout()
    
    # ‰øùÂ≠òÂõæË°®
    results_dir = "results"
    os.makedirs(results_dir, exist_ok=True)
    chart_path = os.path.join(results_dir, f"demo_backtest_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png")
    plt.savefig(chart_path, dpi=300, bbox_inches='tight')
    print(f"üìä ÂõæË°®Â∑≤‰øùÂ≠òËá≥: {chart_path}")
    
    # ÊòæÁ§∫ÂõæË°®
    plt.show()
    
    # 8. ‰øùÂ≠òËØ¶ÁªÜÁªìÊûú
    if total_trades > 0:
        trades_path = os.path.join(results_dir, f"demo_trades_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv")
        trades_df.to_csv(trades_path, index=False)
        print(f"üìÑ ‰∫§ÊòìËÆ∞ÂΩïÂ∑≤‰øùÂ≠òËá≥: {trades_path}")
    
    portfolio_path = os.path.join(results_dir, f"demo_portfolio_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv")
    results_df.to_csv(portfolio_path)
    print(f"üìÑ ËµÑÈáëÊõ≤Á∫øÂ∑≤‰øùÂ≠òËá≥: {portfolio_path}")
    
    print(f"\n{'='*60}")
    print("‚úÖ ÊºîÁ§∫ÂÆåÊàêÔºÅ")
    print("üí° ÊèêÁ§∫ÔºöËøôÊòØ‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆÁöÑÊºîÁ§∫ÔºåÂÆûÈôÖ‰ΩøÁî®Êó∂ÈúÄË¶ÅÈÖçÁΩÆÁúüÂÆûÁöÑAPIÂØÜÈí•")
    print(f"{'='*60}")

if __name__ == "__main__":
    try:
        run_strategy_demo()
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è ÊºîÁ§∫Ë¢´Áî®Êà∑‰∏≠Êñ≠")
    except Exception as e:
        print(f"\n‚ùå ÊºîÁ§∫ËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: {e}")
        import traceback
        traceback.print_exc()
